<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Lang test</title>
    <meta name="description" content="Сравнение производительности некоторых Языков программирования для вычислительных задач">
    <meta name="keywords" content="c++, golang, java, js, nim, rust, php, hhvm, python">

    <noscript><meta http-equiv="refresh" content="0; URL=/badbrowser.php"></noscript>
    <!-- Bootstrap -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<!--<body role="document" id="top">-->
<body>

<!-- CONTAINER -->
<div class="container page-header" role="main">

    <div class="text-center" style="color: #337ab7;" id="what"><h1>
        Сравнение производительности Языков Программирования<br> (для вычислительных задач)</h1>
    </div>
    <p>Автор исследования: <a href="https://rasla.ru/me" title="Личная страничка автора"><b>Разбицкий Вячеслав</b></a><br>
        Дата исследования: <b>2016-03-17</b></p>
    <p>По мотивам статьи 2014-2015 года
        <a href="http://blog.carlesmateo.com/2014/10/13/performance-of-several-languages"
        title="Performance of several languages">Performance of several languages (by Carles Mateo)</a>.</p>

    <div class="text-center" style="color: #337ab7;">
        <h2>Цели и задачи</h2>
    </div>

    <p><b>Цель работы:</b> оценка эффективности <abbr title="Языков Программирования">ЯП</abbr> для вычислительных задач</p>
    <p><b>Идея:</b> заключается в том, что данная оценка эффективности могла бы служить хорошим подспорьем,
        при выборе ЯП для "Вычислителей".</p>
    <p><b>Решаемые задачи:</b></p>
    <ul>
        <li>Сравнение времени исполнения программы (включая время запуска VM / интерпретатора);</li>
        <li>Сравнение потребляемой памяти при исполнении программы;</li>
        <li>Сравнение размера файла исходного (и, в ряде случаев, компилируемого) кода.</li>
        <li>Оценка "легкости" развертывания среды исполнения
            и "пригодности" для "консервативного подхода" в администрировании наших серверов.</li>
    </ul>

    <div class="text-center" style="color: #5bc0de;" id="method">
        <h2>Методика</h2>
    </div>
    <p>Я постарался воспроизвести оригинальное тестирование для интересующего меня набора ЯП (10 240 000 000 итераций с помощью 3 вложенных циклов,
        с минимальным вызовом "библиотечных функций" и наличием условного ветвления),
        но с небольшим изменением:
    </p>

    <ol>
        <li>я сделал <b>2 счетчика</b>:
            <ol>
                <li>оставил <b>i_counter</b> (int) без изменений - инкрементится с каждой итерацией;
                когда он достигает значения 50 - сбрасывается на 0;</li>
                <li>добавил <b>l_counter</b> (int64) - только инкрементится с каждой итерацией (и в итоге становится равен кол-ву итераций).
                <br><i>Тут проявился первый прикол - в некоторых языках пришлось принудительно указывать тип "Int64",
                    не смотря на то, что ОС - 64-битный линукс.</i></li>
            </ol>
        </li>

        <li>В первый цикл верхнего уровня (от 0 до 9) - я добавил вывод на <b>stdout</b>
            номер итерации этого цикла.<br>
            <p>Исходный код адаптировался под конкретный ЯП и выглядел примерно так:</p>
    <pre>rasla@rasla:~/rust > cat test_nim.nim
var i_counter = 0
var l_counter = 0

echo("Test Nim:")

# loops here
for loop1 in countup(0, 10-1):
  echo("loop1: ", loop1)
  for loop2 in countup(0, 32000-1):
    for loop3 in countup(0, 32000-1):
      i_counter += 1
      l_counter += 1

      if i_counter > 50:
        i_counter = 0
echo()
echo("i_Counter: ", i_counter)
echo("l_Counter: ", l_counter)</pre>

            Итого, при запуске в консоли получаем:
            <pre>rasla@rasla:~/rust > time ./test_nim
Test Nim:
loop1: 0
loop1: 1
loop1: 2
loop1: 3
loop1: 4
loop1: 5
loop1: 6
loop1: 7
loop1: 8
loop1: 9

i_Counter: 37
l_Counter: 10240000000

real    0m10.259s
user    0m10.204s
sys     0m0.016s
rasla@rasla:~/rust >
</pre>
        </li>

        <li>Я провел тестирование на более свежих версиях ПО и добавил ЯП, которых не было в оригинальном тесте
            <b>(C#, <a href="https://www.rust-lang.org/" title=" Системный язык программирования,
внимание которого сосредоточено на трёх задачах: безопасность, скорость и параллелизм.
 Он сопоставим по скорости и возможностям с C++, однако, даёт большую безопасность при работе с памятью,
что обеспечивается механизмами ограничения.">Rust</a>,
           <a href="http://nim-lang.org/" title=" Язык программирования со статической типизацией,
поддерживающий процедурный, объектно-ориентированный, функциональный и обобщённый стили программирования,
при этом остающийся простым и эффективным.

Cочетает мощь Lisp, простоту и понятность Python и высокую производительность C.
Важной особенностью, которую Nim унаследовал от Lisp, стало то, что
 абстрактное синтаксическое дерево (AST) является частью спецификации языка,
что позволяет поддерживать мощную систему макросов,
следовательно, обеспечивает создание предметно-ориентированных языков (DSL).">Nim</a>)</b>.
        </li>

        <li>Для сравнения в таблицу добавлены колонки значений <b>потребления памяти</b> (htop).<br>
            Условия запуска (и паразитная нагрузка "десктопа") были идентичными, на моей рабочей станции разработчика.
            <p><i>(AMD Athlon(tm) II X3 440 Processor 3,0 GHz / 1x 4Gb DDR3<br>
            Linux Mint 17.3 KDE amd64 / kernel 4.2.0-34-generic)</i></p>
        </li>

        <li><p>Тест каждого ЯП запускался 3 раза подряд, из которых выбиралось МИНИМАЛЬНОЕ ВРЕМЯ (time <b>real</b>), таким образом:</p>
            <kbd>rasla@rasla:~/rust > time ./test_nim; time ./test_nim; time ./test_nim</kbd>
        </li>
    </ol>

    <div class="text-center" style="color: #5cb85c;" id="res">
        <h2>Результаты</h2>
    </div>
    <p>Файл с таблицей результатов: <a href="lang-test_2016-03.ods" title="Таблица с результатами тестов"><b>lang-test_2016-03.ods</b></a>
    <br>Файл с исходным кодом: <a href="lang-test_2016-03.src.7z" title="7zip-архив с исходным кодом"><b>lang-test_2016-03.src.7z</b></a>
    <p>Для самых нетерпеливых финальная табличка (меньше времени <b>test_time</b> - лучше):</p>
    <img src="lang-test_2016-03.png" alt="Таблица с результатами из файла lang-test_2016-03.ods">

    <div class="text-center" style="color: #f0ad4e;" id="details">
        <h2>Примечания</h2>
    </div>
    <p>1) Теоретический предел минимального времени исполнения цикла на моем компе - <b>6,89 секунд</b>!<br>
        (максимальная частота процессора = 3 GHz; ОС - однозадачный DOS;
        Процессор позволяет за 1 такт выполнить все инкременты, за второй такт сравнить все условия,
        а за третий такт произвести условное обнуление,
        затратами на печать в stdout в данном случае можно пренебречь):</p>
    <pre>Кол-во процессорных тактов:
(1+1) * 10240000000
+ (1) * 10240000000/50
= 20 684 800 000 процессорных тактов

Частота процессора = 3 GHz

Время исполнения кода:
  20684800000
/  3000000000
= 6,8949(3) сек
    </pre>
    <p>2) Как может заметить внимательный читатель (исходного кода) - я сделал неоптимальную последовательность инкрементов:</p>
    <pre>    for loop3 in countup(0, 32000-1):
      i_counter += 1 #c1
      l_counter += 1 #c2

      if i_counter > 50: #c1
        i_counter = 0</pre>
    <p>Конечно же процессору было бы эффективнее "сначала увеличить И сравнить i", а с "L" разбираться потом...<br>
        Сделано это <b>НАМЕРЕННО</b>, чтобы заставить компилятор/интерпретатор помучаться с оптимизацией, если он умеет такое делать.</p>

    <h3>C / C++</h3>
    <p>Более высокая степерь оптимизации (-O3) далеко не всегда лучше "рекомендуемой по-умолчанию" оптимизации (-O2).</p>

    <h3 class="text-success">Nim</h3>
    <p>Победитель среди компилируемых ЯП!<br>
        Как по скорости работы, так и по компактности и понятности исходного кода с ним мало кто сравнится!</p>
    <p>Язык настолько вкусный, что мимо него проходить НЕЛЬЗЯ, хотя бы в академических целях:</p>
    <div class="well">
        <p><b>Nim</b> (ранее известный, как Nimrod) — язык программирования со статической типизацией,
            поддерживающий процедурный, объектно-ориентированный, функциональный и обобщённый стили программирования,
            при этом остающийся простым и эффективным.</p>
        <p><b>Nim</b> сочетает мощь <b>Lisp</b>, простоту и понятность <b>Python</b> и высокую производительность <b>C</b>.<br>
            Важной особенностью, которую Nim унаследовал от Lisp, стало то, что абстрактное
            синтаксическое дерево (AST) является частью спецификации языка,
            что позволяет поддерживать мощную систему макросов и обеспечивает создание предметно-ориентированных языков (DSL).</p>
        <p>При его создании основополагающими были три принципа (перечисляемые в порядке их важности):<br>
            <b>эффективность</b> (efficiency), <b>выразительность</b> (expressiveness) и <b>элегантность</b> (elegancy),
            обозначенные самими авторами, как <b>«3E»</b>.</p>
    </div>

    <h3>Rust</h3>
    <p>ЯП от Mozilla Research, который ГАРАНТИРУЕТ отсутствие ошибки "переполнение буфера".</p>
    <p>Он сопоставим по скорости и возможностям с C++, однако, даёт б<i>O</i>льшую безопасность при работе с памятью.</p>
    <p><i>После нескольких лет активной разработки первая стабильная версия (1.0) вышла 15 мая 2015 года,
        после чего новые версии выходят раз в 6 недель.</i> ("типичный" график выпуска версии для Мозиллы)</p>

    <h3>LuaJIT</h3>
    <p>Первый из "некомпилируемых" ЯП! при этом оказался быстрее "неоптимизированного С++".</p>

    <h3>Golang</h3>
    <p>Очень интересный ЯП тем, что может компилироваться "мгновенно" - что позволяет запускать простые программы "налету".</p>
    <p>"Бинарный файл - <b>самодостаточный</b> и не требует наличия других файлов/библиотек на машине для запуска</p>

    <h3>C#</h3>
    <p>Вот уж чего не ожидал, так это того, что C# окажется быстрее Java (при запуске в ОС Linux 64-bit)!</p>
    <p>Компиляция C#-проекта возможна 3 "стабами": <b>"32"</b> / <b>"64"</b> / <b>"any CPU"</b> (есть ещё "arm64" - но он не проверялся).<br>
        Так же неожиданностью оказалось то, что <b>"64"</b> не запустилась на моей amd64 ОС Linux,
        НО <b>"32"</b> оказалась почти дважды быстрее <b>"any CPU"</b> (и чем "64" на ОС Windows)!</p>

    <h3>Java</h3>
    <p>Все прелести качественного JIT-компилятора: "написано однажды - работает везде" (в рамках своей JRE-платформы), да ещё и насколько быстро!</p>

    <h3>NodeJS</h3>
    <p>JIT-компилятор в виртуальной машине JS (Chromium V8) очень быстро прогрессирует и уже "почти догнал" по скорости Java.</p>
    <p>Так же весьма бросается в глаза "скорость", с которой NodeJS наращивает производительность JS JIT.</p>

    <h3>PHP</h3>
    <p>PHP хорошо прогрессирует, пусть даже и ценой "неполной обратной совместимости" (что, в данном случае, даже "хорошо").<br>
        Версия 7.0 стала ещё почти в 2 раза быстрее и "экономичнее" (чем PHP 5.6) в плане потребления памяти, при исполнении скриптов.</p>
    <p>HHVM оказался в 8 раз быстрее PHP 7.0 (на том же самом коде), но потребляет для этого больше памяти и не полностью совместим с PHP.</p>
    <p>Ещё про HHVM можно добавить, что по опыту эксплуатации, довлоьно часто на него жалуются, что примерно через час работы,
        его приходится рестартовать</p>

    <h3>Python</h3>
    <p>Как и в статье-оригинале, скорость интерпретации в Питоне невелика. Сила Питона в другом,
        том что находится за пределами задач данного исследования.</p>
    <p>Однако, очень сильно меня удивил <b>PyPy 5.0</b> - я ожидал "прирост производительности", но не настолько большой (60 x) - и это ободряет!</p>
    <p></p>

    <div class="text-center" style="color: #d43f3a" id="summary">
        <h2>Выводы</h2>
    </div>
    Результаты статьи оригинала подтвердились далеко не все (включая вывод о том, что "Java8 JIT оказался быстрее С++ (-arch=86_64, -O2)")!<br>
    Хотя с общим выводом я скорее соглашусь (о том, что будущее большей части исполняемых программ, видимо за JIT).</p>
    <p>Однако и разница в методике тестирования очень значительна:</p>
    <ul>
        <li>у него была "чистая ОС", безо всего кроме необходимого для запуска тестируемых программ" - у меня же "обычный десктоп разраба/админа";</li>
        <li>у него суммарно использовалось 4 счетчика, у меня 5.</li>
    </ul>
    <p>Для себя лично открыл просто НЕВЕРОЯТНО интересный, быстрый, компактный и богатый Язык Программирования - <a href="http://nim-lang.org/" title=" Язык программирования со статической типизацией,
поддерживающий процедурный, объектно-ориентированный, функциональный и обобщённый стили программирования,
при этом остающийся простым и эффективным."><b>Nim</b></a> !</p>

</div>
<!-- End of CONTAINER -->

<!-- FOOTER -->
<footer>
    <p class="text-center">Copyright &copy;
        <a href="https://www.rc-online.ru/" title="Сайт компании &laquo;Биллинг-Онлайн&raquo;">Биллинг-Онлайн</a>
    </p>
</footer>
<!-- End of FOOTER -->

<!--  ========== JavaScript scripts ==========  -->
<!-- Placed at the end of the document so the pages load faster -->
<!-- jQuery 1/2 -->
<script src="/js/jquery-1.11.3.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script type="text/javascript">
    $(document).ready(function(){
        $('a[href^="#"]').click( function(){ // если href начинается с '#', то ловим клик
            var p_title='RaSla.lan';
            var scroll_el = $(this).attr('href'); // возьмем содержимое атрибута href
            //console.log('scroll_el = '+scroll_el);
            if (scroll_el == '#') $('html, body').animate({ scrollTop: 0 }, 500);
            else if ($(scroll_el).length != 0) { // проверим существование элемента чтобы избежать ошибки
                // плавно проматываем страницу
                var top = $(scroll_el).offset().top - 60;
                if (top < 0) top = 0;
                //console.log('scroll_el = '+scroll_el+' (scrollTop: $(scroll_el).offset().top = '+top);
                $('html, body').animate({ scrollTop: top }, 500);
                // заголовок для Истории
                p_title = $(scroll_el+' h2').text() + ' - ' + p_title;
                //console.log('title: '+p_title);
            }
            history.pushState({scroll_el: scroll_el, title: p_title}, p_title, scroll_el);
            return false; // выключаем стандартное действие
        });
    });
</script>

</body>
</html>
